\section{Diagrammes de séquence}


\subsection{Ajout d'un noeud}

Le diagramme suivant montre la séquence de l'ajout d'un noeud à la simulation.

\begin{figure}[H]
	\includegraphics[scale=0.5]{fig/DSS/AddNode.jpg}
	\centering
	\caption{Diagramme de séquence: ajout d'un noeud}
	\label{f:dss_addNode}
\end{figure}

Lors de l'ajout d'un noeud, l'employé du RTC sélectionne le mode "Noeud" dans l'interface gratuite. Après, celui-ci clique sur la carte. Lors du clic, un MouseEvent est déclenché. Les positions X et Y sont obtenues avec les fonctions getGridPositionX() et getGridPositionY() de l'affichage.

Par la suite, la fonction createNode() est appellée, où un noeud est créé à l'aide des coordonnées et rajouté à la liste de noeuds du contrôleur. L'affichage est ensuite rafraîchi afin d'inclure le nouveau noeud. Le contrôleur peut obtenir la position des noeuds à partir de la liste de noeuds.
\newpage

\subsection{Ajout d'une arête}

Le diagramme suivant montre la séquence de l'ajout d'un objet Line à la simulation à partir de deux points (noeuds).

\begin{figure}[H]
	\includegraphics[scale=0.8]{fig/DSS/AddLine.jpg}
	\centering
	\caption{Diagramme de séquence: ajout d'une arête}
	\label{f:dss_addLine}
\end{figure}

La fonction addLine() du contrôleur est appellée. Les deux noeuds passées en argument sont cherchées dans la liste de nodes. Si pour quelconque raison un des noeuds n'est pas trouvé dans la liste de noeuds, celui-ci est rajouté à la liste de noeuds du contrôleur. Par la suite, un objet Line est créé rejoignant les deux noeuds. Celui-ci est rajouté à la liste de noeuds.

\newpage

\subsection{Simuler}

Le diagramme suivant montre la séquence du processus de démarrage d'une simulation par l'usager.

\begin{figure}[H]
	\includegraphics[scale=0.3]{fig/DSS/Simulation.jpg}
	\centering
	\caption{Diagramme de séquence: démarrage d'une simulation}
	\label{f:dss_addLine}
\end{figure}

La fonction simulateTick() est utilisée comme un incrément de simulation. Dans le diagramme, la fonction est seulement appellée une seule fois puisque cela correspond au premier cycle de la simulation quand elle est démarrée. Durant cette ittération de simulation, les autobus et les passagers qui sont programmés pour apparaître au temps de départ font leur entrée. De plus, les prochains temps de création de bus et de passagers sont calculés à l'aide de la fonction triangular(). Ce n'est que dans les appelles suivant de simulateTick() dans une boucle correspondant au temps demandé de simulation que les bus vont commencer à se déplacer et où les passagers vont embarquer/débarquer des autobus.

\newpage

\subsection{Distribution triangulaire}

Le diagramme suivant montre comment la fonction triangular() est utilisé afin de déterminer la vitesse d'un segment.

\begin{figure}[H]
	\includegraphics[scale=0.6]{fig/DSS/triangular.jpg}
	\centering
	\caption{Diagramme de séquence: distribution triangulaire de l'assignation de la vitesse à un segment}
	\label{f:dss_triangular}
\end{figure}

La fonction triangular prend la vitesse minimum, typique et maximum configurée pour le segment et calcul alors une valeur aléatoire à partir de la distribution triangulaire afin de déterminer la vitesse des autobus sur le segment lors de la simulation.

\newpage

\subsection{Position d'un autobus}

Le diagramme suivant montre comment sélectionner un autobus sur l'interface et récupérer la position d'un autobus.

\begin{figure}[H]
	\includegraphics[scale=0.4]{fig/DSS/positionBus.jpg}
	\centering
	\caption{Diagramme de séquence: Position d'un autobus}
	\label{f:dss_bus}
\end{figure}

L'utilisateur clique sur un autobus dans la fenêtre de simulation alors que cette dernière est en cours. Lors du clic, un MouseEvent est déclenché. Les positions X et Y sont obtenues avec les fonctions getGridPositionX() et getGridPositionY() de l'affichage. Comme le bus est prioritaire (en premier plan) la fonction de sélection appelle getBusFromClick() qui retour l'objet bus approprié selon la position dans la liste de bus du contrôleur.

La valeur de position centrale de l'autobus peut-être obtenu à l'aide des fonctions getPositionX() et getPositionY() de l'autobus, cet appel peut être fait continuellement pour mettre à jour la position de l'autobus sur l'interface. La fonction selectBus se charge du changement de couleur de l'autobus dans l'interface lors de la sélection.